ref = setdiff(multinom_model.short$lab,labels)
ref
t(sapply(labels,function(i){
dat = df.model_short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
}))
labels = rownames(coefficients(multinom_model.short))
ref = setdiff(multinom_model.short$lab,labels)
t(sapply(labels,function(i){
dat = df.model.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
}))
labels = rownames(coefficients(multinom_model.short))
ref = setdiff(multinom_model.short$lab,labels)
t(sapply(labels,function(i){
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
}))
i=1
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
i=2
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
dat$mod_peche == i
dat$mod_peche
df.mod.short
dat = df.mod.short
dat$mod_peche
as.numeric(dat$mod_peche == i)
i=1
dat = df.mod.short
as.numeric(dat$mod_peche == i)
ref
labels
dat
#Assumption 2: No Multicollinearity
#Check multicollinearity using the Variance Inflation Factor (VIF).
vif_results <- vif(multinom_model.short)
print(vif_results)
#Warning message
#glm.fit: algorithm did not converge
#This warning often occurs when you attempt to fit a logistic regression model in R and you experience perfect separation – that is, a predictor variable is able to perfectly separate the response variable into 0’s and 1’s. (https://www.statology.org/glm-fit-algorithm-did-not-converge/)
labels = rownames(coefficients(multinom_model.short))
ref = setdiff(multinom_model.short$lab,labels)
t(sapply(labels,function(i){
i=1
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
}))
(sapply(labels,function(i){
i=1
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
}))
(sapply(labels,function(i){
#i=1
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
}))
i=1
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
i=2
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
i=1
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
rm(i)
i=2
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
rm(i)
t(sapply(labels,function(i){
#i=2
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
rm(i)
}))
t(sapply(labels,function(i){
#i=2
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
#rm(i)
}))
#Assumption 2: No Multicollinearity
#Check multicollinearity using the Variance Inflation Factor (VIF).
vif_results <- vif(multinom_model.short)
print(vif_results)
t(sapply(labels,function(i){
#i=2
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif.i <- vif(glm(mod_peche ~ .,data=dat,family="binomial"))
#rm(i)
}))
View(vif_results)
t(sapply(labels,function(i){
#i=2
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif.i <<- vif(glm(mod_peche ~ .,data=dat,family="binomial"))
#rm(i)
}))
View(vif.i)
dat$mod_peche
labels
labels
unique(labels[i])
#i=2
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
#i=2
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
t(sapply(labels,function(i){
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif.i <<- vif(glm(mod_peche ~ .,data=dat,family="binomial"))
assign(paste0("vif", unique(labels[[i]]), ".2017to2023"), vif.i)
#rm(i)
}))
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
(sapply(labels,function(i){
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif.i <<- vif(glm(mod_peche ~ .,data=dat,family="binomial"))
assign(paste0("vif", unique(labels[[i]]), ".2017to2023"), vif.i)
#rm(i)
}))
(sapply(labels,function(i){
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif.i <<- vif(glm(mod_peche ~ .,data=dat,family="binomial"))
#assign(paste0("vif", unique(labels[[i]]), ".2017to2023"), vif.i)
#rm(i)
}))
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
for (i in i:length(labels)) {
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif(glm(mod_peche ~ .,data=dat,family="binomial"))
#assign(paste0("vif", unique(labels[[i]]), ".2017to2023"), vif.i)
}
dat$mod_peche == i
as.numeric(dat$mod_peche == i)
dat$mod_peche
t(sapply(labels,function(i){
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif.i <<- vif(glm(mod_peche ~ .,data=dat,family="binomial"))
#assign(paste0("vif", unique(labels[[i]]), ".2017to2023"), vif.i)
#rm(i)
}))
(sapply(labels,function(i){
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif.i <<- vif(glm(mod_peche ~ .,data=dat,family="binomial"))
#assign(paste0("vif", unique(labels[[i]]), ".2017to2023"), vif.i)
#rm(i)
}))
# stepwize regression for Multinomial Logistic Regression Model
# the null model contains only the intercept; the full model contains all predictors
(null_model <- multinom(mod_peche ~ 1, data = df.mod.short))
(multinom_model.short)
# use the stepAIC function from the MASS package, which performs both forward and backward stepwise selection based on AIC (Akaike Information Criterion)
stepwise_model.forward <- stepAIC(null_model, scope = list(lower = null_model, upper = full_model), direction = "both")
multinom_model.short
# use the stepAIC function from the MASS package, which performs both forward and backward stepwise selection based on AIC (Akaike Information Criterion)
stepwise_model.forward <- stepAIC(null_model, scope = list(lower = null_model, upper = multinom_model.short), direction = "both")
stepwise_model.forward$call
stepwise_model.backward <- stepAIC(null_model, scope = list(lower = null_model, upper = multinom_model.short), direction = "backward")
stepwise_model.backward$call
stepwise_model.both <- stepAIC(null_model, scope = list(lower = null_model, upper = multinom_model.short), direction = "both")
stepwise_model.both$call
stepwise_model.forward$call
stepwise_model.backward$call
stepwise_model.both$call
# Make predictions
probabilities <- multinom_model.short %>% predict(test.data, type = "response")
multinom_model.short
# Make predictions
probabilities <- multinom_model.short %>% predict(test.data, type = "response")
predict(test.data, type = "response")
predict
stepwise_model.both$call
View(multinom.tbl.short.sign)
# fit with varaibles that have a significant effect on the dependant variable mod_peche
stepwise_model.both$terms$attr
stepwise_model.both$terms
# fit with varaibles that have a significant effect on the dependant variable mod_peche
stepwise_model.both$terms[1]
# fit with varaibles that have a significant effect on the dependant variable mod_peche
stepwise_model.both$terms[1]
# fit with varaibles that have a significant effect on the dependant variable mod_peche
stepwise_model.both$terms
# fit with varaibles that have a significant effect on the dependant variable mod_peche
stepwise_model.both$terms$names
multinom_model.short.red <- multinom(mod_peche ~
a
#+ res_tour
+ Temps_peche_estime.cat2h
+ zone.gp
, data = df.mod.short)
multinom_model.short.red
summary(multinom_model.short)
#interpret the coefficients in terms of odds ratios
exp(coef(multinom_model.short))
(multinom.tbl.short <- tidy(multinom_model.short, conf.int = TRUE))
(multinom.tbl.short.sign <- filter(multinom.tbl.short, p.value < 0.05))
summary(multinom_model.short.red)
#interpret the coefficients in terms of odds ratios
exp(coef(multinom_model.short.red))
(multinom.tbl.short.red <- tidy(multinom_model.short.red, conf.int = TRUE))
(multinom.tbl.short.red.sign <- filter(multinom.tbl.short.red, p.value < 0.05))
library(rpart)
library(rpart.plot)
# Custom Stepwise Function for Multinomial Logistic Regression
stepwise_multinom <- function(data, response, predictors) {
# Helper function to calculate AIC for a given set of predictors
calculate_aic <- function(predictors) {
formula <- as.formula(paste(response, "~", paste(predictors, collapse = "+")))
model <- multinom(formula, data = data)
return(AIC(model))
}
best_aic <- Inf
best_model <- NULL
current_predictors <- c()
# Forward selection
for (predictor in predictors) {
new_predictors <- c(current_predictors, predictor)
new_aic <- calculate_aic(new_predictors)
if (new_aic < best_aic) {
best_aic <- new_aic
best_model <- new_predictors
}
}
# Backward elimination
improved <- TRUE
while (improved) {
improved <- FALSE
for (predictor in best_model) {
new_predictors <- setdiff(best_model, predictor)
if (length(new_predictors) == 0) break
new_aic <- calculate_aic(new_predictors)
if (new_aic < best_aic) {
best_aic <- new_aic
best_model <- new_predictors
improved <- TRUE
break
}
}
}
# Fit the final model with the selected predictors
final_formula <- as.formula(paste(response, "~", paste(best_model, collapse = "+")))
final_model <- multinom(final_formula, data = data)
return(list(model = final_model, predictors = best_model))
}
stepwise_multinom(data = df.mod.short, response = mod_peche, predictors = c("a", "res_tour", "Temps_peche_estime.cat2h", "zone.gp"))
stepwise_multinom(data = df.mod.short, response = "mod_peche", predictors = c("a", "res_tour", "Temps_peche_estime.cat2h", "zone.gp"))
multinom_model.short.red <- multinom(mod_peche ~
a
#+ res_tour
+ Temps_peche_estime.cat2h
+ zone.gp
, data = df.mod.short)
summary(multinom_model.short.red)
#interpret the coefficients in terms of odds ratios
exp(coef(multinom_model.short.red))
(multinom.tbl.short.red <- tidy(multinom_model.short.red, conf.int = TRUE))
(multinom.tbl.short.red.sign <- filter(multinom.tbl.short.red, p.value < 0.05))
summary(multinom_model.short)$coefficient
#2-tailed Z-test
summary(multinom_model.short)$coefficient/summary(multinom_model.short)$standards.errors
summary(multinom_model.short)$standards.errors
#2-tailed Z-test
summary(multinom_model.short)$coefficient/summary(multinom_model.short)$standard.errors
(1 - pnorm(abs(z), 0, 1))
#2-tailed Z-test
z <- summary(multinom_model.short)$coefficient/summary(multinom_model.short)$standard.errors
(1 - pnorm(abs(z), 0, 1))
p. <- (1 - pnorm(abs(z), 0, 1))
p <- (1 - pnorm(abs(z), 0, 1))
p
p <- (1 - pnorm(abs(z), 0, 1)) * 2
p
(multinom.tbl.short.sign <- filter(multinom.tbl.short, p.value < 0.05))
(p <- (1 - pnorm(abs(z), 0, 1)) * 2)
multinom_model.short <- multinom(mod_peche ~ ., data = df.mod.short)
summary(multinom_model.short)
#interpret the coefficients in terms of odds ratios
exp(coef(multinom_model.short))
(multinom.tbl.short <- tidy(multinom_model.short, conf.int = TRUE))
(multinom.tbl.short.sign <- filter(multinom.tbl.short, p.value < 0.05))
multinom_model.short.sign <- multinom(mod_peche ~ . - res_tour, data = df.mod.short)
summary(multinom_model.short)
multinom_model.short.sign <- multinom(mod_peche ~ . - res_tour, data = df.mod.short)
summary(multinom_model.short.sign)
z <- summary(multinom_model.short.sign)$coefficient/summary(multinom_model.short.sign)$standard.errors
(p <- (1 - pnorm(abs(z), 0, 1)) * 2)
ind <- sample(2, nrwo(df.mod.short), replace = T, prob = c(.6,.4))
ind <- sample(2, nrow(df.mod.short), replace = T, prob = c(.6,.4))
training <- df.mod.short[ind==1]
training <- df.mod.short[ind==1,]
testing <- df.mod.short[ind==2,]
multinom_model.training <- multinom(training ~ . - res_tour, data = training)
# Data partition
set.seed(222)
ind <- sample(2, nrow(df.mod.short), replace = T, prob = c(.6,.4))
training <- df.mod.short[ind==1,]
testing <- df.mod.short[ind==2,]
multinom_model.training <- multinom(mod_peche ~ . - res_tour, data = training)
# Confusion matrix and misclassification error - testing dataS
predict(multinom_model.training, testing)
# Confusion matrix and misclassification error - testing dataS
p1 <- predict(multinom_model.training, training)
# Confusion matrix and misclassification error - testing dataS
p <- predict(multinom_model.training, training)
tab <- table(p, training$mod_peche)
# Confusion matrix and misclassification error - testing dataS
(p <- predict(multinom_model.training, training))
(tab <- table(p, training$mod_peche))
1 - sum(diag(tab))/sum(tab)
unique(df.mod.short$mod_peche)
table(df.mod.short$mod_peche)
table(df.mod.short$mod_peche)
table(training$mod_peche)
table(testing$mod_peche)
multinom_model.training <- multinom(mod_peche ~ . - res_tour, data = training)
# Confusion matrix and misclassification error - testing dataS
(p <- predict(multinom_model.training, training))
(tab <- table(p, training$mod_peche))
1 - sum(diag(tab))/sum(tab) # misclassification
p
# Confusion matrix and misclassification error - testing data
(p1 <- predict(multinom_model.training, testing))
(tab1 <- table(p1, training$mod_peche))
(tab1 <- table(p1, testing$mod_peche))
1 - sum(diag(tab1))/sum(tab1) # misclassification
tab/colSums(tab)
tab1/colSums(tab1)
#Assumption 2: Independence of Irrelevant Alternatives (IIA); i.e. Categories of the outcome variable must be mutually exclusive and exhaustive.
#Use the Hausman-McFadden test to check the IIA assumption. However, this test is not directly available in R, so we'll use an approximation.
# IIA assumption check
iia_test <- function(model, data, formula) {
reduced_model <- update(model, . ~ . - predictor1) # Example, modify as needed
model_ll <- logLik(model)
reduced_model_ll <- logLik(reduced_model)
chi_square <- 2 * (model_ll - reduced_model_ll)
p_value <- pchisq(chi_square, df = length(coef(model)) - length(coef(reduced_model)), lower.tail = FALSE)
return(p_value)
}
iia_result <- iia_test(model = multinom_model.short, data = df.mod.short, mod_peche ~  a + res_tour + Temps_peche_estime.cat2h + zone.gp)
print(iia_result)
#Assumption 3: No Multicollinearity between independent variables.
#Check multicollinearity using the Variance Inflation Factor (VIF).
vif_results <- vif(multinom_model.short)
print(vif_results)
#Warning message
#glm.fit: algorithm did not converge
#This warning often occurs when you attempt to fit a logistic regression model in R and you experience perfect separation – that is, a predictor variable is able to perfectly separate the response variable into 0’s and 1’s. (https://www.statology.org/glm-fit-algorithm-did-not-converge/)
labels = rownames(coefficients(multinom_model.short))
ref = setdiff(multinom_model.short$lab,labels)
t(sapply(labels,function(i){
dat = df.mod.short
dat$mod_peche = as.numeric(dat$mod_peche == i)
vif.i <<- vif(glm(mod_peche ~ .,data=dat,family="binomial"))
}))
# stepwize regression for Multinomial Logistic Regression Model. (http://www.sthda.com/english/articles/36-classification-methods-essentials/150-stepwise-logistic-regression-essentials-in-r/)
# the null model contains only the intercept; the full model contains all predictors
(null_model <- multinom(mod_peche ~ 1, data = df.mod.short))
(multinom_model.short)
# use the stepAIC function from the MASS package, which performs both forward and backward stepwise selection based on AIC (Akaike Information Criterion)
stepwise_model.forward <- stepAIC(null_model, scope = list(lower = null_model, upper = multinom_model.short), direction = "both")
stepwise_model.forward$call
stepwise_model.backward <- stepAIC(null_model, scope = list(lower = null_model, upper = multinom_model.short), direction = "backward")
stepwise_model.backward$call
stepwise_model.both <- stepAIC(null_model, scope = list(lower = null_model, upper = multinom_model.short), direction = "both")
stepwise_model.both$call
stepwise_model.forward$call
stepwise_model.backward$call
stepwise_model.both$call
# Custom Stepwise Function for Multinomial Logistic Regression
stepwise_multinom <- function(data, response, predictors) {
# Helper function to calculate AIC for a given set of predictors
calculate_aic <- function(predictors) {
formula <- as.formula(paste(response, "~", paste(predictors, collapse = "+")))
model <- multinom(formula, data = data)
return(AIC(model))
}
best_aic <- Inf
best_model <- NULL
current_predictors <- c()
# Forward selection
for (predictor in predictors) {
new_predictors <- c(current_predictors, predictor)
new_aic <- calculate_aic(new_predictors)
if (new_aic < best_aic) {
best_aic <- new_aic
best_model <- new_predictors
}
}
# Backward elimination
improved <- TRUE
while (improved) {
improved <- FALSE
for (predictor in best_model) {
new_predictors <- setdiff(best_model, predictor)
if (length(new_predictors) == 0) break
new_aic <- calculate_aic(new_predictors)
if (new_aic < best_aic) {
best_aic <- new_aic
best_model <- new_predictors
improved <- TRUE
break
}
}
}
# Fit the final model with the selected predictors
final_formula <- as.formula(paste(response, "~", paste(best_model, collapse = "+")))
final_model <- multinom(final_formula, data = data)
return(list(model = final_model, predictors = best_model))
}
stepwise_multinom(data = df.mod.short, response = "mod_peche", predictors = c("a", "res_tour", "Temps_peche_estime.cat2h", "zone.gp"))
multinom_model.short.red <- multinom(mod_peche ~ . - res_tour, data = df.mod.short)
summary(multinom_model.short.red)
#interpret the coefficients in terms of odds ratios
exp(coef(multinom_model.short.red))
(multinom.tbl.short.red <- tidy(multinom_model.short.red, conf.int = TRUE))
(multinom.tbl.short.red.sign <- filter(multinom.tbl.short.red, p.value < 0.05))
rownames(exp(coef(multinom_model.short.red)))
rownames(exp(coef(multinom_model.short.red)))[1]
(exp(coef(multinom_model.short.red)))[1]
#interpret the coefficients in terms of odds ratios
exp(coef(multinom_model.short.red))
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] =", (exp(coef(multinom_model.short.red)))[1,]
(exp(coef(multinom_model.short.red)))[1,]
(exp(coef(multinom_model.short.red)))[1,]
(exp(coef(multinom_model.short.red)))[1,]
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] =", (exp(coef(multinom_model.short.red)))[1,]$Intercept
(exp(coef(multinom_model.short.red)))[1,]$Intercept
(exp(coef(multinom_model.short.red)))[1,]$Intercept
(exp(coef(multinom_model.short.red)))[1,]$Intercept
(exp(coef(multinom_model.short.red)))[1,]$Intercept
(exp(coef(multinom_model.short.red)))[1,"Intercept"]
(exp(coef(multinom_model.short.red)))[1,"Intercept"]
(exp(coef(multinom_model.short.red)))
(exp(coef(multinom_model.short.red)))[1,]
(exp(coef(multinom_model.short.red)))[1,1]
(exp(coef(multinom_model.short.red)))[1,2]
names(exp(coef(multinom_model.short.red)))[1,2]
names(exp(coef(multinom_model.short.red)))
(exp(coef(multinom_model.short.red)))
colnames(exp(coef(multinom_model.short.red)))[1,2]
colnames(exp(coef(multinom_model.short.red)))
colnames(exp(coef(multinom_model.short.red)))[2]
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] =", (exp(coef(multinom_model.short.red)))[1,1], " + ", (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + " (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], " + ...")
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + ", (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + " (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], " + ...")
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], "\\+ ", (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + " (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], " + ...")
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], "\\+ ", (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], "\\+ " (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], "\\+  ...")
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], "\\+", (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], "\\+" (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], "\\+")
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1])
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], "\\+")
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " +")
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + " , (exp(coef(multinom_model.short.red)))[1,2])
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + " , (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2])
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + " , (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + " (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], "\\+")
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + " , (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + " (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3])
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + " , (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + ", (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3])
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + " , (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + ", (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], "\\+")
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + " , (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + ", (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], " + ...")
paste0("ln[P(mod_peche=3)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[2,1], " + " , (exp(coef(multinom_model.short.red)))[2,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + ", (exp(coef(multinom_model.short.red)))[2,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], " + ...")
#interpret the coefficients in terms of odds ratios
exp(coef(multinom_model.short.red))
tree_model <- rpart(response ~ . - res_tour, data = df.mod.short, method = "class")
tree_model <- rpart(mod_peche ~ . - res_tour, data = df.mod.short, method = "class")
rpart.plot(tree_model)
tree_model
View(tree_model)
rpart.plot(tree_model, type = 4)
rpart.plot(tree_model, type = 4, extra = class-rate)
rpart.plot(tree_model, type = 4, extra = 2)
