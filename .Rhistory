stepwise_model.backward <- stepAIC(null_model, scope = list(lower = null_model, upper = multinom_model.short), direction = "backward")
stepwise_model.backward$call
stepwise_model.both <- stepAIC(null_model, scope = list(lower = null_model, upper = multinom_model.short), direction = "both")
stepwise_model.both$call
stepwise_model.forward$call
stepwise_model.backward$call
stepwise_model.both$call
# Custom Stepwise Function for Multinomial Logistic Regression
stepwise_multinom <- function(data, response, predictors) {
# Helper function to calculate AIC for a given set of predictors
calculate_aic <- function(predictors) {
formula <- as.formula(paste(response, "~", paste(predictors, collapse = "+")))
model <- multinom(formula, data = data)
return(AIC(model))
}
best_aic <- Inf
best_model <- NULL
current_predictors <- c()
# Forward selection
for (predictor in predictors) {
new_predictors <- c(current_predictors, predictor)
new_aic <- calculate_aic(new_predictors)
if (new_aic < best_aic) {
best_aic <- new_aic
best_model <- new_predictors
}
}
# Backward elimination
improved <- TRUE
while (improved) {
improved <- FALSE
for (predictor in best_model) {
new_predictors <- setdiff(best_model, predictor)
if (length(new_predictors) == 0) break
new_aic <- calculate_aic(new_predictors)
if (new_aic < best_aic) {
best_aic <- new_aic
best_model <- new_predictors
improved <- TRUE
break
}
}
}
# Fit the final model with the selected predictors
final_formula <- as.formula(paste(response, "~", paste(best_model, collapse = "+")))
final_model <- multinom(final_formula, data = data)
return(list(model = final_model, predictors = best_model))
}
stepwise_multinom(data = df.mod.short, response = "mod_peche", predictors = c("a", "res_tour", "Temps_peche_estime.cat2h", "zone.gp"))
multinom_model.short.red <- multinom(mod_peche ~ . - res_tour, data = df.mod.short)
summary(multinom_model.short.red)
#interpret the coefficients in terms of odds ratios
exp(coef(multinom_model.short.red))
(multinom.tbl.short.red <- tidy(multinom_model.short.red, conf.int = TRUE))
(multinom.tbl.short.red.sign <- filter(multinom.tbl.short.red, p.value < 0.05))
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv")
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv", sep = ".", row.names = F)
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv", row.names = F)
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv", row.names = F, dec = ".")
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv", row.names = F)
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv", row.names = F)
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv", row.names = F)
multinom.tbl.short.red
View(multinom.tbl.short.red)
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv", row.names = F)
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv", row.names = F)
write.csv2(multinom.tbl.short.red, "Tables/multinom.2020-2023.csv", row.names = F)
library(xlsx)
library(readxl)
library(xlsx)
install.packages("xlsx")
library(xlsx)
install.packages("WriteXLS")
library(WriteXLS)
WriteXLS(multinom.tbl.short.red, "Tables/multinom.2020-2023.xlsx")
(multinom.tbl.short.red.sign <- filter(multinom.tbl.short.red, p.value < 0.05))
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + " , (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + ", (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], " + ...")
paste0("ln[P(mod_peche=3)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[2,1], " + " , (exp(coef(multinom_model.short.red)))[2,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + ", (exp(coef(multinom_model.short.red)))[2,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], " + ...")
# watch video https://www.youtube.com/watch?v=oxRy2DMrOF4 on how to write the model to add it in a report
(mod1vs2 <- paste0("ln[P(mod_peche=2)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[1,1], " + " , (exp(coef(multinom_model.short.red)))[1,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + ", (exp(coef(multinom_model.short.red)))[1,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], " + ..."))
writeLines(mod1vs2, "Tables/multinom.2020-2023.P1vsP2.txt")
(mod1vs3 <- paste0("ln[P(mod_peche=3)/P(mod_peche=1)] = ", (exp(coef(multinom_model.short.red)))[2,1], " + " , (exp(coef(multinom_model.short.red)))[2,2],"*",colnames(exp(coef(multinom_model.short.red)))[2], " + ", (exp(coef(multinom_model.short.red)))[2,3],"*",colnames(exp(coef(multinom_model.short.red)))[3], " + ..."))
writeLines(mod1vs3, "Tables/multinom.2020-2023.P1vsP3.txt")
tree_model <- rpart(mod_peche ~ . - res_tour, data = df.mod.short, method = "class")
rpart.plot(tree_model, type = 4, extra = 2)
rpart.plot(tree_model, type = 4, extra = 2)
ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4)
tree_model <- rpart(mod_peche ~ . - res_tour, data = df.mod.short, method = "class")
rpart.plot(tree_model, type = 4, extra = 2)
ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4)
#options(warn=-1) #remove warnings
options(warn=0) #print warnings
#Collapse — Alt+L
#Expand — Shift+Alt+L
#Collapse All — Alt+O
#Expand All — Shift+Alt+O
#to add or remove commenting for multiple lines of code: ctl+shift+c
library(readxl)
library(dplyr)
library(tidyr)
library(tibble)
library(stringr)
library(ggplot2)
library(ggbreak)
library(lubridate)
library(hms)
library(chron)
library(janitor)
library(apyramid)
library(FactoMineR)
library(factoextra)
library(fmsb)
library(stringi)
library(nnet)
library(MASS)
library(car)
library(tidyverse)
library(knitr)
library(kableExtra)
library(broom)
library(gtsummary)
library(ggeffects)
library(marginaleffects)
library(rpart)
library(rpart.plot)
`%notin%` <- Negate(`%in%`)
# import DBs and work on DBs ####
#NB among corrections to brought to the excel file prior importation, I had to correct for date, cfr in the excel file %d-%m-%y; however, some ":" as separator, empty " " space before the date etc. So in any case check for these for further data importation.
Meta.survey <- read_excel("BDD_peche_loisir_2024_04_18.xlsx", sheet = "Metha_enquete_terrain_publique", col_names = T, range = "A14:D218")
Meta.survey <- arrange(Meta.survey, Libellé)
Meta.survey$Libellé
survey <- (read_excel("BDD_peche_loisir_2024_04_18.xlsx", sheet = "BDD_enquete_terrain_publique", col_names = T))[ , order(names(read_excel("BDD_peche_loisir_2024_04_18.xlsx", sheet = "BDD_enquete_terrain_publique", col_names = T)))]
names(survey)
sapply(survey, class)
# quid format hh:mm excel => imported as POSIXct ; if you want to force R to import it as character, it doen't work, so keep the automatic importation format.
head(survey$date) ; class(survey$date)
head(survey$Temps_peche_effectif) ; class(survey$Temps_peche_effectif)
head(survey$h_debut) ; class(survey$h_debut)
unique(Meta.survey$Format)
Meta.survey$Format <- ifelse(Meta.survey$Format == "Binaire", "numeric", Meta.survey$Format)
Meta.survey$Format <- ifelse(Meta.survey$Format == "Texte", "character", Meta.survey$Format)
Meta.survey$Format <- ifelse(Meta.survey$Format == "Nombre", "character", Meta.survey$Format) #was numeric before, but some var supposed to be numric must be imported as character cfr e.g. age variable
Meta.survey$Format <- ifelse(Meta.survey$Format == "Alphanumérique", "character", Meta.survey$Format)
Meta.survey$Format <- ifelse(Meta.survey$Format == "Date", "date", Meta.survey$Format)
Meta.survey$Format <- ifelse(Meta.survey$Format == "Horaire", "POSIXct", Meta.survey$Format)
Meta.survey$Format <- ifelse(Meta.survey$Format == "-", "character", Meta.survey$Format)
Meta.survey$Format <- ifelse(Meta.survey$Format == "Réel", "character", Meta.survey$Format) #was numeric before, but some var supposed to be numric must be imported as character cfr age variable
unique(Meta.survey$Format)
# issue with début & fin enquête var. importation
table(survey$deb_sortie)
survey$deb_sortie <- ifelse(survey$deb_sortie == "NA", NA, survey$deb_sortie)
table(survey$fin_sortie)
survey$fin_sortie <- ifelse(survey$fin_sortie == "NA", NA, survey$fin_sortie)
# transform them now in time format for below loop
survey$deb_sortie <- chron::times(as.numeric(survey$deb_sortie))
survey$fin_sortie <- chron::times(as.numeric(survey$fin_sortie))
survey$deb_sortie <- as.POSIXct(ifelse(is.na(survey$deb_sortie), NA, paste0("1899-12-31 ", as.character(survey$deb_sortie))))
survey$fin_sortie <- as.POSIXct(ifelse(is.na(survey$fin_sortie), NA, paste0("1899-12-31 ", as.character(survey$fin_sortie))))
intersect(unique(Meta.survey[,c("Libellé","Unité")])[["Libellé"]], unique(names(survey)))
length(unique(names(survey)))
length(names(survey))
survey[ , names(survey) %in% intersect(unique(Meta.survey[,c("Libellé","Unité")])[["Libellé"]], unique(names(survey)))]
for (i in 1:length(survey)) {
#i=36
names(survey[,i])
typeof(unlist(survey[,i]))
fmt. <- unique(filter(Meta.survey, Libellé == names(survey[,i]))[["Format"]])
fmt. <- ifelse(length(fmt.) == 0, "null", fmt.)
if (fmt. == "date") {
survey[,i] <- as.Date(as.numeric(unlist(survey[,i])), origin = "1899-12-30", format = "%Y-%m-%d")
} else if (fmt. == "POSIXct") {
survey[,i] <- as.POSIXct(unlist(survey[,i]), origin = "1970-01-01 00:00:00", format = "%Y-%m-%d %H:%M:%S")
} else if (fmt. == "numeric") {
survey[,i] <- as.numeric(unlist(survey[,i]))
} else if (fmt. == "character") {
survey[,i] <- as.character(unlist(survey[,i]))
} else {
survey[,i]
}
rm(fmt.,i)
}
head(survey$date)
head(survey$Temps_peche_effectif) ; class(survey$Temps_peche_effectif)
head(survey$h_debut) ; class(survey$h_debut)
setdiff(names(survey), Meta.survey$Libellé)
survey[,setdiff(names(survey), Meta.survey$Libellé)[[1]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[1]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[2]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[2]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[3]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[3]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[4]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[4]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[5]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[5]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[6]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[6]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[7]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[7]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[8]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[8]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[9]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[9]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[10]]] <- as.character(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[10]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[11]]] <- as.character(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[11]]]))
# the two variables "Temps_peche_effectif" & "Temps_peche_estime" were automatically imported as POSIXct variable so don't change anything here
#survey[,setdiff(names(survey), Meta.survey$Libellé)[[12]]] <- as.POSIXct(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[12]]]), origin = "19700-01-01 00:00:00", format = "%Y-%m-%d %H:%M:%S")
#survey[,setdiff(names(survey), Meta.survey$Libellé)[[13]]] <- as.POSIXct(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[13]]]), origin = "1970-01-01 00:00:00", format = "%Y-%m-%d %H:%M:%S")
survey[,setdiff(names(survey), Meta.survey$Libellé)[[14]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[14]]]))
survey[,setdiff(names(survey), Meta.survey$Libellé)[[15]]] <- as.numeric(unlist(survey[,setdiff(names(survey), Meta.survey$Libellé)[[15]]]))
unique(survey$h_debut) ; survey$h_debut <- as_hms(survey$h_debut)
unique(survey$h_fin) ; survey$h_fin <- as_hms(survey$h_fin)
unique(survey$heure_enq) ; survey$heure_enq <- as_hms(survey$heure_enq)
unique(survey$Temps_peche_estime) ; survey$Temps_peche_estime <- as_hms(survey$Temps_peche_estime)
unique(survey$Temps_peche_effectif) ; survey$Temps_peche_effectif <- as_hms(survey$Temps_peche_effectif)
unique(survey$deb_sortie) ; survey$deb_sortie <- as_hms(survey$deb_sortie)
unique(survey$fin_sortie) ; survey$fin_sortie <- as_hms(survey$fin_sortie)
head(survey$date) ; class(survey$date)
head(survey$Temps_peche_effectif) ; class(survey$Temps_peche_effectif)
head(survey$h_debut) ; class(survey$h_debut)
Meta.survey <- read_excel("BDD_peche_loisir_2024_04_18.xlsx", sheet = "Metha_enquete_terrain_publique", col_names = T, range = "A14:D218")
Meta.survey$Libellé
union(names(survey),Meta.survey$Libellé)
setdiff(names(survey),Meta.survey$Libellé)
survey <- survey[,c(intersect(Meta.survey$Libellé,names(survey)), setdiff(names(survey),Meta.survey$Libellé))]
names. <- names(read_excel("BDD_peche_loisir_2024_04_18.xlsx", sheet = "BDD_enquete_terrain_publique", col_names = T))
survey <- survey[,names.]
rm(names.)
survey <- add_column(survey, BD = "PNMCA", .before = "mode_eqt")
# fishing data
fishing.Stareso <- read_excel("Enquetes_Pêche_Loisir_PNMCCA_Chabrier_2023 (1).xlsx", sheet = "BD_Stareso", col_names = T, col_types = c(
"numeric",
"text",
"text",
"date",
"text",
"numeric",
"numeric",
"text",
"text",
"text",
"text",
"text",
"numeric",
"numeric",
"text",
"text",
"numeric",
"numeric",
"date",
"date",
"date",
"date",
"text",
"text",
"text",
"text", #many geographical zone
"text", #many sites
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"numeric",
"numeric",
"numeric",
"numeric",
"text",
"numeric",
"numeric",
"text"))
fishing.Stareso <- filter(fishing.Stareso, !is.na(fiche_n))
head(fishing.Stareso)
names(fishing.Stareso)
fishing.Stareso$heure_deb <- as_hms(fishing.Stareso$heure_deb)
fishing.Stareso$heure_enq <- as_hms(fishing.Stareso$heure_enq)
fishing.Stareso$heure_fin <- as_hms(fishing.Stareso$heure_fin)
fishing.Stareso$temps_pech <- as_hms(fishing.Stareso$temps_pech)
fishing.PNMCA <- read_excel("BDD_peche_loisir_2024_04_18.xlsx", sheet = "BDD_donnees_peche_du_jour", col_names = T, col_types = c(
"numeric",
"text",
"text",
"date",
"text",
"numeric",
"numeric",
"text",
"text",
"text",
"text",
"text",
"numeric",
"numeric",
"numeric",
"numeric",
"text", #lat not in the metadata
"numeric",
"numeric",
"numeric",
"numeric",
"text", #long not in the metadata
"text",
"numeric",
"numeric",
"date",
"date",
"date",
"date",
"date",
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"text",
"text", #cfr nom_scien not numeric but text, error in the metadata
"numeric",
"numeric",
"numeric",
"numeric", #I add to remove "g" and "-" in pds_sor var 168, 169, 185, 190, 253
"text",
"numeric",
"numeric",
"text"))
fishing.PNMCA <- filter(fishing.PNMCA, !is.na(fiche_n))
head(fishing.PNMCA)
names(fishing.PNMCA) # in contrast to the metadata file, the var id_enquete does not appear in the DB; in contrast to the DB, the var lat & long do not appear in the metadata
fishing.PNMCA$heure_deb <- as_hms(fishing.PNMCA$heure_deb)
fishing.PNMCA$heure_enq <- as_hms(fishing.PNMCA$heure_enq)
fishing.PNMCA$heure_fin <- as_hms(fishing.PNMCA$heure_fin)
fishing.PNMCA$temps_pech_effectif <- as_hms(fishing.PNMCA$temps_pech_effectif)
fishing.PNMCA$temps_peche_estime <- as_hms(fishing.PNMCA$temps_peche_estime)
# variables in common and diff
# common var
intersect(names(fishing.Stareso), names(fishing.PNMCA))
# var in PNMCA but not in Stareso
setdiff(names(fishing.PNMCA), names(fishing.Stareso))
# var in Stareso but not in PNMCA
setdiff(names(fishing.Stareso), names(fishing.PNMCA))
# union
union(setdiff(names(fishing.PNMCA), names(fishing.Stareso)), setdiff(names(fishing.Stareso), names(fishing.PNMCA)))
#some var obviously are identical, although with diff names:
# "y_lat_DD" vs "lat (°N)"
# "x_lon_DD" vs "long ((°E)"
# "temps_pech_effectif" vs "temps_pech"
head(fishing.PNMCA$y_lat_DD)
head(fishing.Stareso$`lat (°N)`)
names(fishing.Stareso)[names(fishing.Stareso) == "lat (°N)"] <- "y_lat_DD"
head(fishing.PNMCA$x_lon_DD)
head(fishing.Stareso$`long (°E)`)
names(fishing.Stareso)[names(fishing.Stareso) == "long (°E)"] <- "x_lon_DD"
head(fishing.PNMCA$temps_peche_estime)
head(fishing.PNMCA$temps_pech_effectif)
head(fishing.Stareso$temps_pech) #should I consider Stareso temps_pech as PNMCA temps_pech_effectif or temps_peche_estime ? temps_pech_effectif seems to be more logical cfr field observation and only one temps_peche considered in Stareso DB.
names(fishing.Stareso)[names(fishing.Stareso) == "temps_pech"] <- "temps_pech_effectif"
# merge PNMCA & Stareso dfs and add BD variable to all dfs.
fishing.PNMCA <- add_column(fishing.PNMCA, BD = "PNMCA", .before = "fiche_n")
fishing.Stareso <- add_column(fishing.Stareso, BD = "Stareso", .before = "fiche_n")
fishing <- bind_rows(fishing.PNMCA, fishing.Stareso)
fishing <- fishing[, c(c(intersect(names(fishing.Stareso), names(fishing.PNMCA))), c(setdiff(names(fishing.PNMCA), names(fishing.Stareso))), c(setdiff(names(fishing.Stareso), names(fishing.PNMCA))))]
# compa DB
names(fishing)
names(survey)
setdiff(names(fishing), names(survey))
intersect(names(fishing), names(survey))
#some variable do not coincide between fishing and survey dfs; we have to make names matching for comparison purpose between fishing vs survey!
class(fishing$mod_pech) ; class(survey$mod_peche)
names(fishing)[names(fishing) == "mod_pech"] <- "mod_peche"
class(fishing$lieu_residence) ; class(survey$commune)
names(fishing)[names(fishing) == "lieu_residence"] <- "commune"
class(fishing$x_lon) ; class(survey$x_degres)
names(fishing)[names(fishing) == "long (°E)"] <- "x_degres"
#NB: the var survey$x_degres makes no sense
class(fishing$y_lat) ; class(survey$y_degres)
names(fishing)[names(fishing) == "lat (°N)"] <- "y_degres"
#NB: the var survey$y_degres makes no sense
class(fishing$app_autre) ; class(survey$autre_app)
names(fishing)[names(fishing) == "app_autre"] <- "autre_app"
class(fishing$fond_rech) ; class(survey$fonds_rech)
names(fishing)[names(fishing) == "fond_rech"] <- "fonds_rech"
class(fishing$heure_enq) ; class(survey$heure_enq)
names(fishing)[names(fishing) == "heure_enq"] <- "heure_enq"
class(fishing$temps_pech_effectif) ; class(survey$Temps_peche_effectif)
names(fishing)[names(fishing) == "temps_pech_effectif"] <- "Temps_peche_effectif"
class(fishing$heure_fin) ; class(survey$h_fin)
names(fishing)[names(fishing) == "heure_fin"] <- "h_fin"
class(fishing$heure_deb) ; class(survey$h_debut)
names(fishing)[names(fishing) == "heure_deb"] <- "h_debut"
class(fishing$prof_m) ; class(survey$prof_m_moyen)
names(fishing)[names(fishing) == "prof_m"] <- "prof_m_moyen"
class(fishing$nebulosite) ; class(survey$neb)
#variable neb in survet DB can be changed to character cfr xx-xx% in fishing DB. Change we'll be made in case of DB fusion.
names(fishing)[names(fishing) == "nebulosite"] <- "neb"
class(fishing$force_vent) ; class(survey$force_v)
# format diff cfr not only num for fishing
names(fishing)[names(fishing) == "force_vent"] <- "force_v"
class(fishing$saisie) ; class(survey$Saisie)
names(fishing)[names(fishing) == "saisie"] <- "Saisie"
# some more step by step work on the data according to below code of analysis ####
head(survey$date)
survey %>% separate(date, into = c("a", "m", "j"), remove = F) -> survey
head(fishing$date)
fishing %>% separate(date, into = c("a", "m", "j"), remove = F) -> fishing
unique(survey$sexe)
survey$sexe <- ifelse(survey$sexe == "Homme", "homme", survey$sexe)
survey$age_moyen <- as.numeric(survey$age_moyen)
unique(fishing$mod_peche)
fishing$mod_peche <- ifelse(fishing$mod_peche == "PDB", "pdb", fishing$mod_peche)
fishing$mod_peche <- ifelse(fishing$mod_peche == "PE", "pe", fishing$mod_peche)
fishing$mod_peche <- ifelse(fishing$mod_peche == "CSM", "csm", fishing$mod_peche)
saveRDS(survey, "Raw data_mined/enquetes.rds")
write.csv2(survey, "Raw data_mined/enquetes.csv")
saveRDS(fishing, "Raw data_mined/terrain.rds")
write.csv2(survey, "Raw data_mined/terrain.csv")
tree_model <- rpart(mod_peche ~ . - res_tour, data = df.mod.short, method = "class")
rpart.plot(tree_model, type = 4, extra = 2)
ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4)
p. <- rpart.plot(tree_model, type = 4, extra = 2)
p. <- rpart.plot(tree_model, type = 4, extra = 2)
p.
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350)
tree_model <- rpart(mod_peche ~ . - res_tour, data = df.mod.short, method = "class")
rpart.plot(tree_model, type = 4, extra = 2)
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
# Close the device
dev.off()
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350, res = 600)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
rpart.plot(tree_model, type = 4, extra = 2)
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350, res = 600)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350, res = 300)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 300, height = 175, res = 300)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 300, height = 175, res = 150)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
tree_model <- rpart(mod_peche ~ . - res_tour, data = df.mod.short, method = "class")
rpart.plot(tree_model, type = 4, extra = 2)
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 300, height = 175, res = 150)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 300, height = 175, res = 150)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
# Close the device
dev.off()
rpart.plot(tree_model, type = 4, extra = 2)
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350, res = 300)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
# Close the device
dev.off()
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350, res = 150)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
# Close the device
dev.off()
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
# Close the device
dev.off()
#ggsave("Figs/Tree/tree_2020-2023.png", width = 7, height = 4) #doesn't save the plot with ggsave !
# Open a PNG device
png("Figs/Tree/tree_2020-2023.png", width = 600, height = 350)
# Plot the decision tree
rpart.plot(tree_model, type = 4, extra = 2)
# Close the device
dev.off()
tree_model <- rpart(mod_peche ~ . - res_tour, data = df.mod.short, method = "class")
rpart.plot(tree_model, type = 4, extra = 2)
# Close the device
dev.off()
